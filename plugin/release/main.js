/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  RAGSettingTab: () => RAGSettingTab,
  default: () => RAGPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/api/RAGApi.ts
var RAGApi = class {
  constructor(baseUrl, apiKey) {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
  }
  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    if (this.apiKey) {
      options.headers = {
        ...options.headers,
        "Authorization": `Bearer ${this.apiKey}`
      };
    }
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }
    return response.json();
  }
  async search(query, maxResults = 5) {
    return this.request("/search", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ query, max_results: maxResults })
    });
  }
  async chat(query, vaultName) {
    return this.request("/chat", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ query, vault_name: vaultName })
    });
  }
  async listVaults() {
    return this.request("/vaults");
  }
  async addVault(config) {
    return this.request("/vault", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(config)
    });
  }
  async processVault(name) {
    return this.request(`/vault/${name}/process`, {
      method: "POST"
    });
  }
  async getServerStatus() {
    return this.request("/");
  }
  async indexDocument(document2) {
    await this.request("/index", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ document: document2 })
    });
  }
  async runBenchmark() {
    return this.request("/benchmark", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  serverUrl: "http://localhost:8000",
  apiKey: "",
  autoStartServer: true,
  embedModel: "all-MiniLM-L6-v2",
  maxResults: 5,
  chunkSize: 500,
  chunkOverlap: 50,
  preserveMarkdown: true,
  useNeuralEngine: true,
  debugMode: false
};

// src/services/rag-service.ts
var import_obsidian2 = require("obsidian");
var RAGService = class {
  constructor(settings, app, plugin) {
    this.settings = settings;
    this.app = app;
    this.plugin = plugin;
    this.isIndexing = false;
    this.indexingProgress = {
      isIndexing: false,
      progress: 0,
      totalFiles: 0,
      processedFiles: 0
    };
  }
  async search(query, maxResults) {
    try {
      const response = await this.plugin.api.search(query, maxResults || this.settings.maxResults);
      return response.results;
    } catch (error) {
      console.error("Search error:", error);
      throw error;
    }
  }
  async indexVault() {
    if (this.isIndexing) {
      return;
    }
    this.isIndexing = true;
    this.indexingProgress = {
      isIndexing: true,
      progress: 0,
      totalFiles: 0,
      processedFiles: 0
    };
    try {
      const files = this.app.vault.getFiles();
      const markdownFiles = files.filter((file) => file.extension === "md");
      this.indexingProgress.totalFiles = markdownFiles.length;
      const batchSize = 10;
      for (let i = 0; i < markdownFiles.length; i += batchSize) {
        const batch = markdownFiles.slice(i, i + batchSize);
        await this.indexBatch(batch);
        this.indexingProgress.processedFiles += batch.length;
        this.indexingProgress.progress = this.indexingProgress.processedFiles / this.indexingProgress.totalFiles;
      }
      new import_obsidian2.Notice("Vault indexing complete");
    } catch (error) {
      console.error("Indexing error:", error);
      throw error;
    } finally {
      this.isIndexing = false;
      this.indexingProgress.isIndexing = false;
    }
  }
  async indexBatch(files) {
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        await this.plugin.api.indexDocument({
          content,
          metadata: {
            path: file.path,
            name: file.name,
            size: file.stat.size,
            created: file.stat.ctime,
            modified: file.stat.mtime
          }
        });
      } catch (error) {
        console.error(`Error indexing file ${file.path}:`, error);
      }
    }
  }
  async handleFileModify() {
  }
  async runBenchmark() {
    try {
      await this.plugin.api.runBenchmark();
    } catch (error) {
      console.error("Benchmark error:", error);
      throw error;
    }
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getIndexingStatus() {
    return this.indexingProgress;
  }
  async openSearch() {
    await this.plugin.activateView();
  }
};

// src/services/server-manager.ts
var import_child_process = require("child_process");
var import_os = require("os");
var import_obsidian3 = require("obsidian");
var path = __toESM(require("path"));
var ServerManager = class {
  constructor(plugin) {
    this.process = null;
    this.plugin = plugin;
    this.settings = plugin.settings;
    this.serverPath = this.getServerPath();
    this.isRunning = false;
  }
  getServerPath() {
    const pluginDir = path.resolve(__dirname, "../../..");
    const serverDir = path.join(pluginDir, "server");
    return path.join(serverDir, "src", "main.py");
  }
  async initialize() {
    if (this.plugin.settings.autoStartServer) {
      await this.startServer();
    }
  }
  async startServer() {
    var _a, _b;
    if (this.isRunning) {
      return;
    }
    try {
      const env = {
        ...process.env,
        PYTHONUNBUFFERED: "1",
        RAG_SERVER_PORT: new URL(this.settings.serverUrl).port,
        RAG_DEBUG: this.settings.debugMode ? "1" : "0",
        RAG_CACHE_ENABLED: this.settings.cacheEnabled ? "1" : "0",
        RAG_CACHE_SIZE_MB: this.settings.maxCacheSize.toString(),
        RAG_USE_NEURAL_ENGINE: this.settings.useNeuralEngine ? "1" : "0"
      };
      const pythonCommand = (0, import_os.platform)() === "win32" ? "python" : "python3";
      this.process = (0, import_child_process.spawn)(pythonCommand, [this.serverPath], {
        env,
        stdio: ["ignore", "pipe", "pipe"]
      });
      (_a = this.process.stdout) == null ? void 0 : _a.on("data", (data) => {
        if (this.settings.debugMode) {
          console.log(`[RAG Server]: ${data}`);
        }
      });
      (_b = this.process.stderr) == null ? void 0 : _b.on("data", (data) => {
        console.error(`[RAG Server Error]: ${data}`);
        new import_obsidian3.Notice(`RAG Server Error: ${data}`);
      });
      this.process.on("error", (err) => {
        console.error("[RAG Server] Failed to start:", err);
        new import_obsidian3.Notice("Failed to start RAG server");
        this.process = null;
      });
      this.process.on("exit", (code) => {
        if (code !== 0) {
          console.error(`[RAG Server] Exited with code ${code}`);
          new import_obsidian3.Notice(`RAG server exited unexpectedly (code ${code})`);
        }
        this.process = null;
      });
      await this.waitForServer();
      this.isRunning = true;
      new import_obsidian3.Notice("Server started successfully");
    } catch (error) {
      console.error("Error starting server:", error);
      new import_obsidian3.Notice("Error starting server");
      this.process = null;
    }
  }
  async stopServer() {
    if (!this.process) {
      return;
    }
    try {
      return new Promise((resolve2) => {
        if (!this.process) {
          resolve2();
          return;
        }
        this.process.once("exit", () => {
          this.process = null;
          this.isRunning = false;
          resolve2();
        });
        this.process.kill();
        setTimeout(() => {
          if (this.process) {
            this.process.kill("SIGKILL");
            this.process = null;
            this.isRunning = false;
            resolve2();
          }
        }, 5e3);
      });
      new import_obsidian3.Notice("Server stopped successfully");
    } catch (error) {
      console.error("Error stopping server:", error);
      new import_obsidian3.Notice("Error stopping server");
    }
  }
  async getStatus() {
    const url = this.settings.serverUrl;
    try {
      if (!this.process) {
        return {
          isRunning: false,
          url
        };
      }
      const response = await fetch(`${url}/health`);
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }
      return {
        isRunning: true,
        url,
        pid: this.process.pid
      };
    } catch (error) {
      return {
        isRunning: false,
        url,
        error: error.message
      };
    }
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async waitForServer() {
    const maxAttempts = 30;
    const interval = 1e3;
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const status = await this.getStatus();
        if (status.isRunning) {
          return;
        }
      } catch (error) {
      }
      await new Promise((resolve2) => setTimeout(resolve2, interval));
    }
    throw new Error("Server failed to start within timeout");
  }
  async shutdown() {
    await this.stopServer();
  }
  isServerRunning() {
    return this.isRunning;
  }
};

// src/components/status-bar.ts
var import_obsidian4 = require("obsidian");
var StatusBar = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.statusBarEl = plugin.addStatusBarItem();
    this.serverStatusEl = this.statusBarEl.createDiv();
    this.indexingStatusEl = this.statusBarEl.createDiv();
    this.updateStatus();
  }
  async updateStatus() {
    const serverStatus = await this.plugin.serverManager.getStatus();
    const indexingStatus = this.plugin.ragService.getIndexingStatus();
    this.updateServerStatus(serverStatus);
    this.updateIndexingStatus(indexingStatus);
  }
  updateServerStatus(status) {
    this.serverStatusEl.empty();
    if (status.isRunning) {
      this.serverStatusEl.setText("RAG Server: Running");
      this.serverStatusEl.addClass("rag-status-running");
      this.serverStatusEl.removeClass("rag-status-stopped");
    } else {
      this.serverStatusEl.setText("RAG Server: Stopped");
      this.serverStatusEl.addClass("rag-status-stopped");
      this.serverStatusEl.removeClass("rag-status-running");
    }
    this.serverStatusEl.addEventListener("click", async () => {
      if (status.isRunning) {
        await this.plugin.serverManager.stopServer();
      } else {
        await this.plugin.serverManager.startServer();
      }
      await this.updateStatus();
    });
  }
  updateIndexingStatus(status) {
    this.indexingStatusEl.empty();
    if (status.isIndexing) {
      const progress = Math.round(status.processedFiles / status.totalFiles * 100);
      this.indexingStatusEl.setText(`Indexing: ${progress}%`);
      this.indexingStatusEl.addClass("rag-status-indexing");
    } else {
      this.indexingStatusEl.setText("Index: Ready");
      this.indexingStatusEl.removeClass("rag-status-indexing");
    }
    this.indexingStatusEl.addEventListener("click", async () => {
      if (!status.isIndexing) {
        await this.plugin.ragService.indexVault();
        await this.updateStatus();
      }
    });
  }
  showStatusModal(serverStatus, indexingStatus) {
    const modal = new import_obsidian4.Modal(this.plugin.app);
    modal.titleEl.setText("RAG Status");
    const contentEl = modal.contentEl;
    contentEl.empty();
    const serverSection = contentEl.createDiv();
    serverSection.createEl("h3", { text: "Server Status" });
    serverSection.createEl("p", { text: `Status: ${serverStatus.isRunning ? "Running" : "Stopped"}` });
    if (serverStatus.error) {
      serverSection.createEl("p", { text: `Error: ${serverStatus.error}`, cls: "error" });
    }
    const indexSection = contentEl.createDiv();
    indexSection.createEl("h3", { text: "Indexing Status" });
    if (indexingStatus.isIndexing) {
      const progress = Math.round(indexingStatus.processedFiles / indexingStatus.totalFiles * 100);
      indexSection.createEl("p", { text: `Progress: ${progress}%` });
      indexSection.createEl("p", { text: `Files: ${indexingStatus.processedFiles}/${indexingStatus.totalFiles}` });
    } else {
      indexSection.createEl("p", { text: "Not currently indexing" });
    }
    modal.open();
  }
  onunload() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
    }
  }
  setDefaultStatus() {
    this.statusBarEl.empty();
    this.statusBarEl.createEl("span", {
      text: "RAG: Ready",
      cls: "rag-status"
    });
  }
  setStatus(text) {
    this.statusBarEl.empty();
    this.statusBarEl.createEl("span", {
      text: `RAG: ${text}`,
      cls: "rag-status"
    });
  }
  setError(text) {
    this.statusBarEl.empty();
    this.statusBarEl.createEl("span", {
      text: `RAG: Error - ${text}`,
      cls: "rag-status rag-error"
    });
  }
};

// src/views/search-view.ts
var import_obsidian5 = require("obsidian");
var import_obsidian6 = require("obsidian");
var SearchView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return "rag-search";
  }
  getDisplayText() {
    return "RAG Search";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const searchContainer = container.createDiv("rag-search-container");
    const inputContainer = searchContainer.createDiv("rag-search-input-container");
    this.searchInput = inputContainer.createEl("input", {
      type: "text",
      placeholder: "Search your vault..."
    });
    const searchButton = inputContainer.createEl("button", {
      text: "Search"
    });
    this.loadingIndicator = searchContainer.createDiv("rag-loading-indicator");
    this.loadingIndicator.setText("Searching...");
    this.loadingIndicator.hide();
    this.resultsContainer = searchContainer.createDiv("rag-results-container");
    this.searchInput.addEventListener("keypress", async (e) => {
      if (e.key === "Enter") {
        await this.performSearch();
      }
    });
    searchButton.addEventListener("click", async () => {
      await this.performSearch();
    });
    this.addStyles();
  }
  async performSearch() {
    const query = this.searchInput.value.trim();
    if (!query) {
      return;
    }
    try {
      this.showLoading();
      this.resultsContainer.empty();
      const results = await this.plugin.ragService.search(
        query,
        this.plugin.settings.maxResults
      );
      this.displayResults(results);
    } catch (error) {
      console.error("Search error:", error);
      new import_obsidian5.Notice("Search failed. Please try again.");
    } finally {
      this.hideLoading();
    }
  }
  displayResults(results) {
    if (!results.length) {
      this.resultsContainer.createDiv("rag-no-results").setText("No results found");
      return;
    }
    results.forEach((result) => {
      const resultEl = this.resultsContainer.createDiv("rag-result");
      const header = resultEl.createDiv("rag-result-header");
      const title = header.createDiv("rag-result-title");
      title.setText(result.metadata.name || result.source);
      const score = header.createDiv("rag-result-score");
      score.setText(`${Math.round(result.similarity * 100)}% match`);
      const content = resultEl.createDiv("rag-result-content");
      content.setText(result.content);
      resultEl.addEventListener("click", () => {
        this.openResult(result);
      });
    });
  }
  async openResult(result) {
    try {
      const file = this.app.vault.getAbstractFileByPath(result.source);
      if (file) {
        await this.openFile(file);
      }
    } catch (error) {
      console.error("Error opening file:", error);
      new import_obsidian5.Notice("Could not open file");
    }
  }
  async openFile(file) {
    if (file instanceof import_obsidian6.TFile) {
      await this.app.workspace.getLeaf().openFile(file);
    }
  }
  showLoading() {
    this.loadingIndicator.show();
    this.searchInput.disabled = true;
  }
  hideLoading() {
    this.loadingIndicator.hide();
    this.searchInput.disabled = false;
    this.searchInput.focus();
  }
  addStyles() {
    this.containerEl.addClass("rag-view");
    const style = document.createElement("style");
    style.textContent = `
            .rag-search-container {
                padding: 16px;
            }
            
            .rag-search-input-container {
                display: flex;
                gap: 8px;
                margin-bottom: 16px;
            }
            
            .rag-search-input-container input {
                flex: 1;
                padding: 8px;
                border-radius: 4px;
                border: 1px solid var(--background-modifier-border);
            }
            
            .rag-search-input-container button {
                padding: 8px 16px;
                border-radius: 4px;
                background-color: var(--interactive-accent);
                color: var(--text-on-accent);
                border: none;
                cursor: pointer;
            }
            
            .rag-loading-indicator {
                text-align: center;
                padding: 16px;
                color: var(--text-muted);
            }
            
            .rag-result {
                padding: 16px;
                margin-bottom: 16px;
                border-radius: 4px;
                background-color: var(--background-primary);
                border: 1px solid var(--background-modifier-border);
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .rag-result:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }
            
            .rag-result-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .rag-result-title {
                font-weight: bold;
                color: var(--text-normal);
            }
            
            .rag-result-score {
                font-size: 0.8em;
                color: var(--text-muted);
            }
            
            .rag-result-content {
                color: var(--text-muted);
                font-size: 0.9em;
                line-height: 1.5;
                max-height: 100px;
                overflow: hidden;
                position: relative;
            }
            
            .rag-result-content::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 40px;
                background: linear-gradient(
                    transparent,
                    var(--background-primary)
                );
            }
            
            .rag-no-results {
                text-align: center;
                padding: 32px;
                color: var(--text-muted);
            }
        `;
    document.head.appendChild(style);
  }
};

// src/main.ts
(0, import_obsidian7.addIcon)("rag", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`);
var RAGPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.api = new RAGApi(this.settings.serverUrl, this.settings.apiKey);
    this.ragService = new RAGService(this.settings, this.app, this);
    this.serverManager = new ServerManager(this);
    this.statusBar = new StatusBar(this);
    this.registerView(
      "rag-search",
      (leaf) => {
        this.searchView = new SearchView(leaf, this);
        return this.searchView;
      }
    );
    this.addSettingTab(new import_obsidian7.PluginSettingTab(this.app, this));
    await this.serverManager.initialize();
    this.addCommand({
      id: "rag-search",
      name: "Search with RAG",
      callback: () => this.ragService.openSearch()
    });
    this.addCommand({
      id: "rag-index",
      name: "Index current vault",
      callback: () => this.ragService.indexVault()
    });
    if (this.settings.autoStartServer) {
      await this.serverManager.startServer();
    }
    this.registerEvent(
      this.app.workspace.on("file-open", async () => {
        await this.statusBar.updateStatus();
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async () => {
        await this.ragService.handleFileModify();
      })
    );
  }
  async onunload() {
    await this.serverManager.shutdown();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.ragService.updateSettings(this.settings);
    this.serverManager.updateSettings(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType("rag-search")[0];
    if (!leaf) {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: "rag-search" });
        workspace.revealLeaf(leaf);
      }
    } else {
      workspace.revealLeaf(leaf);
    }
  }
};
var RAGSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "RAG Settings" });
    new import_obsidian7.Setting(containerEl).setName("Server URL").setDesc("URL of the RAG server").addText((text) => text.setPlaceholder("Enter server URL").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
      this.plugin.settings.serverUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("API Key").setDesc("Optional API key for server authentication").addText((text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Auto-start Server").setDesc("Automatically start the server when plugin loads").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartServer).onChange(async (value) => {
      this.plugin.settings.autoStartServer = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Cache Enabled").setDesc("Enable caching of embeddings").addToggle((toggle) => toggle.setValue(this.plugin.settings.cacheEnabled).onChange(async (value) => {
      this.plugin.settings.cacheEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Cache Size").setDesc("Maximum cache size in MB").addSlider((slider) => slider.setLimits(100, 1e3, 100).setValue(this.plugin.settings.maxCacheSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxCacheSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Embedding Model").setDesc("Model to use for text embeddings").addDropdown((dropdown) => dropdown.addOption("all-MiniLM-L6-v2", "MiniLM-L6").addOption("all-mpnet-base-v2", "MPNet Base").setValue(this.plugin.settings.embedModel).onChange(async (value) => {
      this.plugin.settings.embedModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Max Results").setDesc("Maximum number of search results to display").addSlider((slider) => slider.setLimits(1, 20, 1).setValue(this.plugin.settings.maxResults).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxResults = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Use Neural Engine").setDesc("Use Apple Neural Engine when available").addToggle((toggle) => toggle.setValue(this.plugin.settings.useNeuralEngine).onChange(async (value) => {
      this.plugin.settings.useNeuralEngine = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Debug Mode").setDesc("Enable debug logging").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
  }
};
